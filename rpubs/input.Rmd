---
title: "MiSTer Controller Latency"
author: "Porkchop Express, Lemonici"
output:
  html_document:
    theme: cosmo
---

<style>
/* Wider container */
.main-container {
  max-width: 1600px !important;
  margin-left: auto;
  margin-right: auto;
  padding-left: 15px;
  padding-right: 15px;
}

/* Make tables scroll horizontally on small screens */
.dataTables_wrapper {
  overflow-x: auto;
}

/* Improve plotly chart container */
.plotly {
  width: 100% !important;
}

/* Better spacing for filter checkboxes */
.crosstalk-input-checkboxgroup label {
  margin-right: 15px;
  white-space: nowrap;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  .main-container {
    max-width: 95% !important;
  }
}
</style>

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
library(gsheet)
library(DT)
library(crosstalk)
library(plotly)
library(htmlwidgets)

# Helper function to truncate long device names
truncate_name <- function(name, max_chars = 40) {
  ifelse(nchar(name) > max_chars,
         paste0(substr(name, 1, max_chars - 3), "..."),
         name)
}

# Color palettes for consistent styling
connection_colors <- c(
  "Wired" = "#2ECC71",
  "Wireless" = "#9B59B6"
)

category_colors <- c(
  "Arcade Stick" = "#E74C3C",
  "Controller" = "#3498DB",
  "Adapter" = "#F39C12",
  "Arcade Encoder" = "#1ABC9C",
  "Gamepad" = "#3498DB",
  "Flight Stick" = "#E67E22",
  "Racing Wheel" = "#34495E",
  "Other" = "#95A5A6"
)

wireless_type_colors <- c(
  "Bluetooth" = "#8E44AD",
  "2.4 GHz" = "#16A085"
)
```

```{r load-gsheet-data, echo=FALSE, warning=FALSE}
dat_raw <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1KlRObr3Be4zLch7Zyqg6qCJzGuhyGmXaOIUrpfncXIM/edit#gid=0')
dat <- dat_raw %>%
  mutate(Row = 2:(nrow(dat_raw) + 1)) %>%
  filter(`Valid Results` == "YES") %>%
  select(
    Make, Model, Device, Link, Connection,
    "Wired/Wireless" = `Wired / Wireless`,
    "WirelessConnection" = `Wireless Connection`,
    `Home Button`,
    `Latency Tier`,
    "Latency (in ms)" = `Average Measured Latency (in ms)`,
    "SD" = `Standard Deviation of Measured Latency (in ms)`,
    "Max" = `Max Measured Latency (in ms)`,
    "Min" = `Min Measured Latency (in ms)`,
    Category, `Face Buttons`, Row, `Date Added`
  ) %>%
  filter(!is.na(`Latency (in ms)`)) %>%
  arrange(`Latency (in ms)`) %>%
  mutate(
    `Missed` = ifelse(`Latency (in ms)` < 100 / 6, `Latency (in ms)` / (100 / 6), 1),
    `On Time` = 1 - Missed,
    ID = row_number(),
    DeviceClean = Device,
    Device = ifelse(is.na(Link),
                    Device,
                    paste0('<a target=_blank href=', Link, '>', Device, '</a>'))
  ) %>%
  distinct(DeviceClean, Connection, .keep_all = TRUE)
```

```{r load-csv-data, echo=FALSE, warning=FALSE}
# Load raw CSV captures for detailed analysis
csv_dir <- "../captures/"
csv_files <- list.files(csv_dir, pattern = "\\.csv$", full.names = TRUE)

load_csv_with_device <- function(file_path) {
  device_name <- tools::file_path_sans_ext(basename(file_path))
  tryCatch({
    df <- read.csv(file_path, stringsAsFactors = FALSE)
    if (ncol(df) >= 2) {
      colnames(df)[1:2] <- c("read", "delay")
      df$Device <- device_name
      df <- df %>% select(Device, read, delay)
      return(df)
    }
    return(NULL)
  }, error = function(e) NULL)
}

raw_data <- lapply(csv_files, load_csv_with_device) %>%
  bind_rows() %>%
  filter(!is.na(delay))

# Calculate percentile statistics from raw data
raw_stats <- raw_data %>%
  group_by(Device) %>%
  summarise(
    N = n(),
    RawMean = mean(delay, na.rm = TRUE),
    RawSD = sd(delay, na.rm = TRUE),
    Median = median(delay, na.rm = TRUE),
    P90 = quantile(delay, 0.90, na.rm = TRUE),
    P95 = quantile(delay, 0.95, na.rm = TRUE),
    P99 = quantile(delay, 0.99, na.rm = TRUE),
    IQR = IQR(delay, na.rm = TRUE),
    RawMin = min(delay, na.rm = TRUE),
    RawMax = max(delay, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  mutate(Consistency = round(100 * (1 - RawSD / RawMean), 1))
```

```{r sd-imputation, echo=FALSE, warning=FALSE}
# SD imputation via linear regression (restored from backup)
dat$Device <- factor(dat$Device, levels = unique(dat$Device))
fit <- lm(data = dat, SD ~ `Latency (in ms)` + Min)
dat$Imputed <- is.na(dat$SD)
dat$SD[dat$Imputed] <- predict.lm(fit, dat[dat$Imputed, ])

dat <- dat %>%
  mutate(
    `SD up` = `Latency (in ms)` + qnorm(.975) * SD,
    `SD down` = `Latency (in ms)` - qnorm(.975) * SD
  )

# Merge raw stats where available (fuzzy match on device name)
dat <- dat %>%
  left_join(raw_stats, by = c("DeviceClean" = "Device"), suffix = c("", "_raw"))
```

# Latency Overview

You can find the full spreadsheet [here](https://docs.google.com/spreadsheets/d/1KlRObr3Be4zLch7Zyqg6qCJzGuhyGmXaOIUrpfncXIM/edit#gid=0). If you see a controller you'd like more info on, its row value listed here will match the "Detailed Results" tab. Store links are often affiliate.

```{r latency-filters, echo=FALSE}
keep <- c("Device", "Latency (in ms)", "SD", "Category", "Connection", "Latency Tier", "Row")
keep_logical <- names(dat) %in% keep

shared_dat <- SharedData$new(dat)
bscols(widths = c(12),
  list(
    filter_select("Make", "Make", shared_dat, ~Make),
    filter_checkbox("Connection", "Connection", shared_dat, ~`Wired/Wireless`,
                    inline = TRUE),
    filter_checkbox("Home Button", "Home Button", shared_dat, ~`Home Button`,
                    inline = TRUE),
    filter_checkbox("Category", "Category", shared_dat, ~Category,
                    inline = TRUE),
    filter_checkbox("Face Buttons", "Face Buttons", shared_dat, ~`Face Buttons`,
                    inline = TRUE),
    filter_checkbox("Latency Tier", "Latency Tier", shared_dat, ~`Latency Tier`,
                    inline = TRUE)
  )
)

datatable(shared_dat,
          options = list(
            autowidth = TRUE,
            fixedColumns = TRUE,
            pageLength = 25,
            columnDefs = list(list(visible = FALSE,
                                   targets = (1:ncol(dat))[!keep_logical]))
          ),
          escape = FALSE)
```

# Recently Added

```{r recently-added, echo=FALSE}
keep_logical <- names(dat) %in% c(keep, "Date Added")

datatable(dat[rev(order(as.Date(dat$`Date Added`, format = "%m/%d/%Y"))), ],
          options = list(
            autowidth = TRUE,
            fixedColumns = TRUE,
            pageLength = 20,
            columnDefs = list(list(visible = FALSE,
                                   targets = (1:ncol(dat))[!keep_logical]))
          ),
          escape = FALSE)
```

# Summary Statistics

```{r summary-stats, echo=FALSE, warning=FALSE}
# Wired vs Wireless statistical comparison
wired_latency <- dat %>% filter(`Wired/Wireless` == "Wired") %>% pull(`Latency (in ms)`)
wireless_latency <- dat %>% filter(`Wired/Wireless` == "Wireless") %>% pull(`Latency (in ms)`)

if (length(wired_latency) > 2 && length(wireless_latency) > 2) {
  t_result <- t.test(wired_latency, wireless_latency)
}
```

**Overall Statistics:**

- Total devices tested: `r nrow(dat)`
- Wired devices: `r sum(dat$'Wired/Wireless' == "Wired", na.rm = TRUE)` (mean latency: `r round(mean(wired_latency, na.rm = TRUE), 2)` ms)
- Wireless devices: `r sum(dat$'Wired/Wireless' == "Wireless", na.rm = TRUE)` (mean latency: `r round(mean(wireless_latency, na.rm = TRUE), 2)` ms)
- One frame threshold: `r round(100/6, 2)` ms (60 Hz)

```{r wired-wireless-ttest, echo=FALSE, results='asis'}
if (exists("t_result")) {
  cat(sprintf("\n**Wired vs Wireless t-test:** t = %.2f, p-value = %.4f %s\n",
              t_result$statistic,
              t_result$p.value,
              ifelse(t_result$p.value < 0.05, "(statistically significant)", "(not significant)")))
}
```

```{r category-summary, echo=FALSE}
category_stats <- dat %>%
  group_by(Category) %>%
  summarise(
    Count = n(),
    `Mean Latency` = round(mean(`Latency (in ms)`, na.rm = TRUE), 2),
    `Median Latency` = round(median(`Latency (in ms)`, na.rm = TRUE), 2),
    `Min` = round(min(`Latency (in ms)`, na.rm = TRUE), 2),
    `Max` = round(max(`Latency (in ms)`, na.rm = TRUE), 2),
    .groups = 'drop'
  ) %>%
  arrange(`Mean Latency`)

datatable(category_stats,
          options = list(pageLength = 10, dom = 't'),
          caption = "Latency by Category")
```

# Interactive Charts

In all plots, the dashed red line corresponds to one frame (16.67 ms at 60 Hz).

## Wired vs. Wireless

```{r wired-wireless-plotly, echo=FALSE, fig.height=8, fig.width=12, warning=FALSE}
p_wired <- dat %>%
  filter(!is.na(`Wired/Wireless`)) %>%
  ggplot(aes(x = `Wired/Wireless`, y = `Latency (in ms)`,
             color = `Wired/Wireless`, text = DeviceClean)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
  scale_color_manual(values = connection_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  labs(title = "Wired vs. Wireless Latency Distribution") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

ggplotly(p_wired, tooltip = c("text", "y"), width = 1000, height = 500) %>%
  layout(hovermode = "closest")
```

## 2.4GHz Wireless vs. Bluetooth

```{r bt-vs-24ghz-plotly, echo=FALSE, fig.height=8, fig.width=12, warning=FALSE}
wireless_dat <- dat %>%
  filter(WirelessConnection %in% c("Bluetooth", "2.4 GHz"))

if (nrow(wireless_dat) > 0) {
  p_wireless <- wireless_dat %>%
    ggplot(aes(x = WirelessConnection, y = `Latency (in ms)`,
               color = WirelessConnection, text = DeviceClean)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
    scale_color_manual(values = wireless_type_colors) +
    geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
    xlab("Wireless Type") +
    ylab("Latency (in ms)") +
    labs(title = "2.4GHz Wireless vs. Bluetooth Latency") +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text = element_text(size = 11),
          axis.title = element_text(size = 12))

  ggplotly(p_wireless, tooltip = c("text", "y"), width = 1000, height = 500) %>%
    layout(hovermode = "closest")
}
```

## Latency by Rank

```{r latency-rank-plotly, echo=FALSE, fig.width=14, warning=FALSE}
dat_ranked <- dat %>%
  arrange(`Latency (in ms)`) %>%
  mutate(Rank = row_number())

p_rank <- dat_ranked %>%
  ggplot(aes(x = Rank, y = `Latency (in ms)`,
             color = `Wired/Wireless`, text = DeviceClean)) +
  geom_point(alpha = 0.7, size = 2.5) +
  scale_color_manual(values = connection_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  xlab("Rank (Lower = Better)") +
  ylab("Latency (in ms)") +
  labs(title = "Latency by Rank") +
  theme_minimal() +
  theme(axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

ggplotly(p_rank, tooltip = c("text", "y", "x"), width = 1200, height = 500) %>%
  layout(hovermode = "closest")
```

## Category Comparison

```{r category-boxplot-plotly, echo=FALSE, fig.height=10, fig.width=14, warning=FALSE}
p_category <- dat %>%
  filter(!is.na(Category)) %>%
  ggplot(aes(x = reorder(Category, `Latency (in ms)`, FUN = median),
             y = `Latency (in ms)`, fill = Category, text = DeviceClean)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
  scale_fill_manual(values = category_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  coord_flip() +
  labs(title = "Latency Distribution by Category",
       x = "Category", y = "Latency (in ms)") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 12))

ggplotly(p_category, tooltip = c("text", "y"), width = 1200, height = 600) %>%
  layout(hovermode = "closest")
```

# Raw Data Deep Dive

This section analyzes the raw capture data from individual controller tests, providing detailed latency distribution insights.

```{r raw-data-available, echo=FALSE}
n_devices_raw <- length(unique(raw_data$Device))
n_readings <- nrow(raw_data)
```

**Raw data available:** `r n_devices_raw` devices with `r format(n_readings, big.mark = ",")` total readings.

## Percentile Statistics from Raw Captures

```{r raw-percentile-table, echo=FALSE}
if (nrow(raw_stats) > 0) {
  raw_stats_display <- raw_stats %>%
    arrange(RawMean) %>%
    select(Device, N, RawMean, Median, P90, P95, P99, Consistency) %>%
    rename(
      `Readings` = N,
      `Mean (ms)` = RawMean,
      `Median (ms)` = Median,
      `P90 (ms)` = P90,
      `P95 (ms)` = P95,
      `P99 (ms)` = P99,
      `Consistency %` = Consistency
    ) %>%
    mutate(across(where(is.numeric), ~round(., 2)))

  datatable(raw_stats_display,
            options = list(pageLength = 15, scrollX = TRUE),
            caption = "Percentile statistics from raw capture data (lower is better, higher consistency is better)")
}
```

## Latency Distribution by Device

Select a device to view its latency distribution histogram.

```{r raw-histogram-interactive, echo=FALSE, warning=FALSE}
if (nrow(raw_data) > 0) {
  # Get all devices sorted by mean latency
  device_list <- raw_stats %>%
    arrange(RawMean) %>%
    pull(Device)

  # Create histogram data for each device
  hist_plots <- lapply(device_list, function(dev) {
    dev_data <- raw_data %>% filter(Device == dev)
    plot_ly(x = ~dev_data$delay, type = "histogram",
            nbinsx = 40, name = dev,
            marker = list(color = '#3498DB', line = list(color = '#2980B9', width = 1))) %>%
      layout(
        shapes = list(
          list(type = "line", x0 = 100/6, x1 = 100/6, y0 = 0, y1 = 1,
               yref = "paper", line = list(color = "#BA1B1D", dash = "dash", width = 2))
        )
      )
  })

  # Create dropdown buttons
  buttons <- lapply(seq_along(device_list), function(i) {
    visibility <- rep(FALSE, length(device_list))
    visibility[i] <- TRUE
    list(
      method = "update",
      args = list(list(visible = visibility)),
      label = truncate_name(device_list[i], 50)
    )
  })

  # Combine all traces
  p_hist <- plot_ly()
  for (i in seq_along(device_list)) {
    dev_data <- raw_data %>% filter(Device == device_list[i])
    p_hist <- p_hist %>%
      add_histogram(x = ~dev_data$delay, name = device_list[i],
                    visible = (i == 1),
                    marker = list(color = '#3498DB'))
  }

  p_hist %>%
    layout(
      title = list(text = "Latency Distribution", y = 0.95),
      xaxis = list(title = "Latency (ms)"),
      yaxis = list(title = "Count"),
      showlegend = FALSE,
      shapes = list(
        list(type = "line", x0 = 100/6, x1 = 100/6, y0 = 0, y1 = 1,
             yref = "paper", line = list(color = "#BA1B1D", dash = "dash", width = 2))
      ),
      updatemenus = list(
        list(
          type = "dropdown",
          active = 0,
          buttons = buttons,
          x = 0.0,
          xanchor = "left",
          y = 1.15,
          yanchor = "top"
        )
      ),
      annotations = list(
        list(text = "Select Device:", x = 0, xref = "paper", xanchor = "left",
             y = 1.22, yref = "paper", showarrow = FALSE)
      ),
      margin = list(t = 100)
    )
}
```

## Time-Series Pattern Viewer

Select a device to view its latency over time. Look for periodic sawtooth patterns indicating polling intervals.

```{r raw-timeseries-interactive, echo=FALSE, warning=FALSE}
if (nrow(raw_data) > 0) {
  # Get devices with at least 100 readings
  devices_with_data <- raw_data %>%
    count(Device) %>%
    filter(n >= 100) %>%
    arrange(desc(n)) %>%
    pull(Device)

  # Create dropdown buttons
  buttons_ts <- lapply(seq_along(devices_with_data), function(i) {
    visibility <- rep(FALSE, length(devices_with_data))
    visibility[i] <- TRUE
    list(
      method = "update",
      args = list(list(visible = visibility)),
      label = truncate_name(devices_with_data[i], 50)
    )
  })

  # Build plot with all device traces
  p_ts <- plot_ly()
  for (i in seq_along(devices_with_data)) {
    dev_data <- raw_data %>%
      filter(Device == devices_with_data[i]) %>%
      slice_head(n = 500)  # First 500 readings

    p_ts <- p_ts %>%
      add_trace(x = ~dev_data$read, y = ~dev_data$delay,
                type = 'scatter', mode = 'lines+markers',
                name = devices_with_data[i],
                visible = (i == 1),
                line = list(color = '#3498DB', width = 1),
                marker = list(color = '#3498DB', size = 3))
  }

  p_ts %>%
    layout(
      title = list(text = "Latency Time Series (First 500 Readings)", y = 0.95),
      xaxis = list(title = "Reading Number"),
      yaxis = list(title = "Latency (ms)"),
      showlegend = FALSE,
      shapes = list(
        list(type = "line", x0 = 0, x1 = 1, xref = "paper",
             y0 = 100/6, y1 = 100/6,
             line = list(color = "#BA1B1D", dash = "dash", width = 2))
      ),
      updatemenus = list(
        list(
          type = "dropdown",
          active = 0,
          buttons = buttons_ts,
          x = 0.0,
          xanchor = "left",
          y = 1.15,
          yanchor = "top"
        )
      ),
      annotations = list(
        list(text = "Select Device:", x = 0, xref = "paper", xanchor = "left",
             y = 1.22, yref = "paper", showarrow = FALSE)
      ),
      margin = list(t = 100),
      height = 500
    )
}
```

## Consistency Analysis

Devices with higher consistency scores have more predictable latency (less variance relative to mean).

```{r consistency-plotly, echo=FALSE, fig.width=12, warning=FALSE}
if (nrow(raw_stats) > 0) {
  p_consistency <- raw_stats %>%
    filter(!is.na(Consistency)) %>%
    mutate(DeviceShort = truncate_name(Device, 40)) %>%
    ggplot(aes(x = RawMean, y = Consistency, text = DeviceShort)) +
    geom_point(aes(size = N), alpha = 0.7, color = '#2708A0') +
    geom_hline(yintercept = 90, color = '#22A722', linetype = "dashed") +
    geom_vline(xintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
    labs(title = "Latency vs Consistency",
         subtitle = "Green line: 90% consistency threshold. Red line: one frame.",
         x = "Mean Latency (ms)", y = "Consistency Score (%)",
         size = "# Readings") +
    theme_minimal() +
    theme(axis.text = element_text(size = 10),
          axis.title = element_text(size = 11))

  ggplotly(p_consistency, tooltip = c("text", "x", "y"), width = 1200, height = 500) %>%
    layout(hovermode = "closest")
}
```

# Latency Ranges

These plots show approximate latency ranges using 95% confidence intervals. Due to limited data, some standard deviations were imputed using linear regression. Imputed values are shown in a different color.

Use the filters below to show specific device types and connection methods.

```{r latency-range-filters, echo=FALSE}
# Prepare data for filtered plot
range_plot_dat <- dat %>%
  filter(!is.na(`Wired/Wireless`), !is.na(Category)) %>%
  mutate(
    DeviceLabel = gsub("<[^>]+>", "", Device),
    DeviceShort = truncate_name(DeviceLabel, 45)
  )

shared_range_dat <- SharedData$new(range_plot_dat)

bscols(widths = c(12),
  list(
    filter_checkbox("ConnectionType", "Connection", shared_range_dat, ~`Wired/Wireless`, inline = TRUE),
    filter_checkbox("DeviceCategory", "Category", shared_range_dat, ~Category, inline = TRUE)
  )
)
```

```{r latency-range-plot, echo=FALSE, fig.height=25, fig.width=14, warning=FALSE}
# Sort data by latency (low to high) and create ordered factor for y-axis
range_plot_sorted <- range_plot_dat %>%
  arrange(`Latency (in ms)`) %>%
  mutate(DeviceShort = factor(DeviceShort, levels = rev(unique(DeviceShort))))

# Calculate appropriate height
plot_height <- max(600, nrow(range_plot_sorted) * 20)

# Create the plot using ggplot + plotly for better control
p_range_gg <- range_plot_sorted %>%
  ggplot(aes(x = `Latency (in ms)`, y = DeviceShort,
             text = paste0(DeviceLabel,
                          "\nLatency: ", round(`Latency (in ms)`, 2), " ms",
                          "\nCategory: ", Category,
                          "\nConnection: ", `Wired/Wireless`))) +
  geom_errorbarh(aes(xmin = `SD down`, xmax = `SD up`,
                     color = factor(Imputed, levels = c(TRUE, FALSE))),
                 height = 0.3) +
  geom_point(size = 2, color = "#333") +
  geom_vline(xintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  scale_color_manual(values = c("TRUE" = "#E63946", "FALSE" = "#457B9D"),
                     labels = c("TRUE" = "Imputed SD", "FALSE" = "Measured SD")) +
  labs(title = "Device Latency Ranges (95% CI)",
       subtitle = "Sorted by average latency (lowest first)",
       x = "Latency (ms)", y = "", color = "SD Source") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 7),
        legend.position = "bottom")

ggplotly(p_range_gg, tooltip = "text", height = plot_height, width = 1400) %>%
  layout(hovermode = "closest",
         margin = list(l = 280, t = 80, b = 80))
```

<br><br>

<small>**Note:** Red error bars indicate imputed standard deviation (estimated via linear regression). Blue bars are measured values.</small>

<br><br>

# Best Performers by Category

Top 3 performing devices in each category, separated by wired and wireless connection.

```{r best-performers, echo=FALSE}
# Get top 3 wired devices per category
best_wired <- dat %>%
  filter(`Wired/Wireless` == "Wired", !is.na(Category)) %>%
  group_by(Category) %>%
  slice_min(`Latency (in ms)`, n = 3, with_ties = FALSE) %>%
  mutate(Rank = row_number()) %>%
  ungroup() %>%
  mutate(Connection = "Wired") %>%
  select(Category, Connection, Rank, Device = DeviceClean, `Latency (in ms)`)

# Get top 3 wireless devices per category
best_wireless <- dat %>%
  filter(`Wired/Wireless` == "Wireless", !is.na(Category)) %>%
  group_by(Category) %>%
  slice_min(`Latency (in ms)`, n = 3, with_ties = FALSE) %>%
  mutate(Rank = row_number()) %>%
  ungroup() %>%
  mutate(Connection = "Wireless") %>%
  select(Category, Connection, Rank, Device = DeviceClean, `Latency (in ms)`)

# Combine and arrange
best_performers <- bind_rows(best_wired, best_wireless) %>%
  arrange(Category, Connection, Rank) %>%
  mutate(
    `Latency (in ms)` = round(`Latency (in ms)`, 2),
    Rank = paste0("#", Rank)
  )

datatable(best_performers,
          options = list(
            pageLength = 50,
            dom = 'ft',
            columnDefs = list(
              list(className = 'dt-left', targets = c(0, 1, 3)),
              list(className = 'dt-center', targets = 2),
              list(className = 'dt-right', targets = 4)
            )
          ),
          filter = 'top',
          rownames = FALSE,
          caption = "Top 3 devices per category and connection type (lowest latency)")
```

# Methodology

This data was collected using a closed-loop latency testing system consisting of:

- **Arduino Pro Micro** - Triggers virtual button presses and measures response time via hardware interrupt
- **DE10-nano with MiSTer FPGA** - Running the NES Lag Tester core to detect inputs
- **Custom test PCB** - Connects the Arduino, controller pins, and DE10-nano

The Arduino triggers a button press on the controller under test, and measures the time until the MiSTer core detects the input. Results are captured via serial output in CSV format.

For more details, see the [GitHub repository](https://github.com/misteraddons/inputlatency).
