---
title: "MiSTer Controller Latency"
author: "Porkchop Express, Lemonici"
output:
  html_document:
    theme: cosmo
---

<style>
/* Wider container */
.main-container {
  max-width: 1600px !important;
  margin-left: auto;
  margin-right: auto;
  padding-left: 15px;
  padding-right: 15px;
}

/* Make tables scroll horizontally on small screens */
.dataTables_wrapper {
  overflow-x: auto;
}

/* Improve plotly chart container */
.plotly {
  width: 100% !important;
}

/* Better spacing for filter checkboxes */
.crosstalk-input-checkboxgroup label {
  margin-right: 15px;
  white-space: nowrap;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
  .main-container {
    max-width: 95% !important;
  }
}
</style>

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(ggplot2)
library(gsheet)
library(DT)
library(crosstalk)
library(plotly)
library(htmlwidgets)

# Helper function to truncate long device names
truncate_name <- function(name, max_chars = 40) {
  ifelse(nchar(name) > max_chars,
         paste0(substr(name, 1, max_chars - 3), "..."),
         name)
}

# Color palettes for consistent styling
connection_colors <- c(
  "Wired" = "#2ECC71",
  "Wireless" = "#9B59B6"
)

category_colors <- c(
  "Arcade Stick" = "#E74C3C",
  "Controller" = "#3498DB",
  "Adapter" = "#F39C12",
  "Arcade Encoder" = "#1ABC9C",
  "Gamepad" = "#3498DB",
  "Flight Stick" = "#E67E22",
  "Racing Wheel" = "#34495E",
  "Other" = "#95A5A6"
)

wireless_type_colors <- c(
  "Bluetooth" = "#8E44AD",
  "2.4 GHz" = "#16A085"
)
```

```{r load-gsheet-data, echo=FALSE, warning=FALSE}
dat_raw <- gsheet2tbl('https://docs.google.com/spreadsheets/d/1KlRObr3Be4zLch7Zyqg6qCJzGuhyGmXaOIUrpfncXIM/edit#gid=0')
dat <- dat_raw %>%
  mutate(Row = 2:(nrow(dat_raw) + 1)) %>%
  filter(`Valid Results` == "YES") %>%
  select(
    Make, Model, Device, Link, Connection,
    "Wired/Wireless" = `Wired / Wireless`,
    "WirelessConnection" = `Wireless Connection`,
    `Home Button`,
    `Latency Tier`,
    "Latency (in ms)" = `Average Measured Latency (in ms)`,
    "SD" = `Standard Deviation of Measured Latency (in ms)`,
    "Max" = `Max Measured Latency (in ms)`,
    "Min" = `Min Measured Latency (in ms)`,
    Category, `Face Buttons`, Row, `Date Added`
  ) %>%
  filter(!is.na(`Latency (in ms)`)) %>%
  arrange(`Latency (in ms)`) %>%
  mutate(
    `Missed` = ifelse(`Latency (in ms)` < 100 / 6, `Latency (in ms)` / (100 / 6), 1),
    `On Time` = 1 - Missed,
    ID = row_number(),
    DeviceClean = Device,
    Device = ifelse(is.na(Link),
                    Device,
                    paste0('<a target=_blank href=', Link, '>', Device, '</a>'))
  ) %>%
  distinct(DeviceClean, Connection, .keep_all = TRUE)
```

```{r load-csv-data, echo=FALSE, warning=FALSE}
# Load raw CSV captures for detailed analysis
csv_dir <- "../captures/"
csv_files <- list.files(csv_dir, pattern = "\\.csv$", full.names = TRUE)

load_csv_with_device <- function(file_path) {
  device_name <- tools::file_path_sans_ext(basename(file_path))
  tryCatch({
    df <- read.csv(file_path, stringsAsFactors = FALSE)
    if (ncol(df) >= 2) {
      colnames(df)[1:2] <- c("read", "delay")
      df$Device <- device_name
      df <- df %>% select(Device, read, delay)
      return(df)
    }
    return(NULL)
  }, error = function(e) NULL)
}

raw_data <- lapply(csv_files, load_csv_with_device) %>%
  bind_rows() %>%
  filter(!is.na(delay))

# Calculate percentile statistics from raw data
raw_stats <- raw_data %>%
  group_by(Device) %>%
  summarise(
    N = n(),
    RawMean = mean(delay, na.rm = TRUE),
    RawSD = sd(delay, na.rm = TRUE),
    Median = median(delay, na.rm = TRUE),
    P90 = quantile(delay, 0.90, na.rm = TRUE),
    P95 = quantile(delay, 0.95, na.rm = TRUE),
    P99 = quantile(delay, 0.99, na.rm = TRUE),
    IQR = IQR(delay, na.rm = TRUE),
    RawMin = min(delay, na.rm = TRUE),
    RawMax = max(delay, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  mutate(Consistency = round(100 * (1 - RawSD / RawMean), 1))
```

```{r sd-imputation, echo=FALSE, warning=FALSE}
# SD imputation via linear regression (restored from backup)
dat$Device <- factor(dat$Device, levels = unique(dat$Device))
fit <- lm(data = dat, SD ~ `Latency (in ms)` + Min)
dat$Imputed <- is.na(dat$SD)
dat$SD[dat$Imputed] <- predict.lm(fit, dat[dat$Imputed, ])

dat <- dat %>%
  mutate(
    `SD up` = `Latency (in ms)` + qnorm(.975) * SD,
    `SD down` = `Latency (in ms)` - qnorm(.975) * SD
  )

# Merge raw stats where available (fuzzy match on device name)
dat <- dat %>%
  left_join(raw_stats, by = c("DeviceClean" = "Device"), suffix = c("", "_raw"))
```

# Latency Overview

You can find the full spreadsheet [here](https://docs.google.com/spreadsheets/d/1KlRObr3Be4zLch7Zyqg6qCJzGuhyGmXaOIUrpfncXIM/edit#gid=0). If you see a controller you'd like more info on, its row value listed here will match the "Detailed Results" tab. Store links are often affiliate.

```{r latency-filters, echo=FALSE}
keep <- c("Device", "Latency (in ms)", "SD", "Category", "Connection", "Latency Tier", "Row")
keep_logical <- names(dat) %in% keep

shared_dat <- SharedData$new(dat)
bscols(widths = c(12),
  list(
    filter_select("Make", "Make", shared_dat, ~Make),
    filter_checkbox("Connection", "Connection", shared_dat, ~`Wired/Wireless`,
                    inline = TRUE),
    filter_checkbox("Home Button", "Home Button", shared_dat, ~`Home Button`,
                    inline = TRUE),
    filter_checkbox("Category", "Category", shared_dat, ~Category,
                    inline = TRUE),
    filter_checkbox("Face Buttons", "Face Buttons", shared_dat, ~`Face Buttons`,
                    inline = TRUE),
    filter_checkbox("Latency Tier", "Latency Tier", shared_dat, ~`Latency Tier`,
                    inline = TRUE)
  )
)

datatable(shared_dat,
          options = list(
            autowidth = TRUE,
            fixedColumns = TRUE,
            pageLength = 25,
            columnDefs = list(list(visible = FALSE,
                                   targets = (1:ncol(dat))[!keep_logical]))
          ),
          escape = FALSE)
```

# Recently Added

```{r recently-added, echo=FALSE}
keep_logical <- names(dat) %in% c(keep, "Date Added")

datatable(dat[rev(order(as.Date(dat$`Date Added`, format = "%m/%d/%Y"))), ],
          options = list(
            autowidth = TRUE,
            fixedColumns = TRUE,
            pageLength = 20,
            columnDefs = list(list(visible = FALSE,
                                   targets = (1:ncol(dat))[!keep_logical]))
          ),
          escape = FALSE)
```

# Summary Statistics

```{r summary-stats, echo=FALSE, warning=FALSE}
# Wired vs Wireless statistical comparison
wired_latency <- dat %>% filter(`Wired/Wireless` == "Wired") %>% pull(`Latency (in ms)`)
wireless_latency <- dat %>% filter(`Wired/Wireless` == "Wireless") %>% pull(`Latency (in ms)`)

if (length(wired_latency) > 2 && length(wireless_latency) > 2) {
  t_result <- t.test(wired_latency, wireless_latency)
}
```

**Overall Statistics:**

- Total devices tested: `r nrow(dat)`
- Wired devices: `r sum(dat$'Wired/Wireless' == "Wired", na.rm = TRUE)` (mean latency: `r round(mean(wired_latency, na.rm = TRUE), 2)` ms)
- Wireless devices: `r sum(dat$'Wired/Wireless' == "Wireless", na.rm = TRUE)` (mean latency: `r round(mean(wireless_latency, na.rm = TRUE), 2)` ms)
- One frame threshold: `r round(100/6, 2)` ms (60 Hz)

```{r wired-wireless-ttest, echo=FALSE, results='asis'}
if (exists("t_result")) {
  cat(sprintf("\n**Wired vs Wireless t-test:** t = %.2f, p-value = %.4f %s\n",
              t_result$statistic,
              t_result$p.value,
              ifelse(t_result$p.value < 0.05, "(statistically significant)", "(not significant)")))
}
```

```{r category-summary, echo=FALSE}
category_stats <- dat %>%
  group_by(Category) %>%
  summarise(
    Count = n(),
    `Mean Latency` = round(mean(`Latency (in ms)`, na.rm = TRUE), 2),
    `Median Latency` = round(median(`Latency (in ms)`, na.rm = TRUE), 2),
    `Min` = round(min(`Latency (in ms)`, na.rm = TRUE), 2),
    `Max` = round(max(`Latency (in ms)`, na.rm = TRUE), 2),
    .groups = 'drop'
  ) %>%
  arrange(`Mean Latency`)

datatable(category_stats,
          options = list(pageLength = 10, dom = 't'),
          caption = "Latency by Category")
```

# Interactive Charts

In all plots, the dashed red line corresponds to one frame (16.67 ms at 60 Hz).

## Wired vs. Wireless

```{r wired-wireless-plotly, echo=FALSE, fig.height=8, fig.width=12, warning=FALSE}
p_wired <- dat %>%
  filter(!is.na(`Wired/Wireless`)) %>%
  ggplot(aes(x = `Wired/Wireless`, y = `Latency (in ms)`,
             color = `Wired/Wireless`, text = DeviceClean)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
  scale_color_manual(values = connection_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  labs(title = "Wired vs. Wireless Latency Distribution") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

ggplotly(p_wired, tooltip = c("text", "y"), width = 1000, height = 500) %>%
  layout(hovermode = "closest")
```

## 2.4GHz Wireless vs. Bluetooth

```{r bt-vs-24ghz-plotly, echo=FALSE, fig.height=8, fig.width=12, warning=FALSE}
wireless_dat <- dat %>%
  filter(WirelessConnection %in% c("Bluetooth", "2.4 GHz"))

if (nrow(wireless_dat) > 0) {
  p_wireless <- wireless_dat %>%
    ggplot(aes(x = WirelessConnection, y = `Latency (in ms)`,
               color = WirelessConnection, text = DeviceClean)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
    scale_color_manual(values = wireless_type_colors) +
    geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
    xlab("Wireless Type") +
    ylab("Latency (in ms)") +
    labs(title = "2.4GHz Wireless vs. Bluetooth Latency") +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text = element_text(size = 11),
          axis.title = element_text(size = 12))

  ggplotly(p_wireless, tooltip = c("text", "y"), width = 1000, height = 500) %>%
    layout(hovermode = "closest")
}
```

## Latency by Rank

```{r latency-rank-plotly, echo=FALSE, fig.width=14, warning=FALSE}
dat_ranked <- dat %>%
  arrange(`Latency (in ms)`) %>%
  mutate(Rank = row_number())

p_rank <- dat_ranked %>%
  ggplot(aes(x = Rank, y = `Latency (in ms)`,
             color = `Wired/Wireless`, text = DeviceClean)) +
  geom_point(alpha = 0.7, size = 2.5) +
  scale_color_manual(values = connection_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  xlab("Rank (Lower = Better)") +
  ylab("Latency (in ms)") +
  labs(title = "Latency by Rank") +
  theme_minimal() +
  theme(axis.text = element_text(size = 11),
        axis.title = element_text(size = 12))

ggplotly(p_rank, tooltip = c("text", "y", "x"), width = 1200, height = 500) %>%
  layout(hovermode = "closest")
```

## Category Comparison

```{r category-boxplot-plotly, echo=FALSE, fig.height=10, fig.width=14, warning=FALSE}
p_category <- dat %>%
  filter(!is.na(Category)) %>%
  ggplot(aes(x = reorder(Category, `Latency (in ms)`, FUN = median),
             y = `Latency (in ms)`, fill = Category, text = DeviceClean)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6, size = 2) +
  scale_fill_manual(values = category_colors) +
  geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
  coord_flip() +
  labs(title = "Latency Distribution by Category",
       x = "Category", y = "Latency (in ms)") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 12))

ggplotly(p_category, tooltip = c("text", "y"), width = 1200, height = 600) %>%
  layout(hovermode = "closest")
```

# Raw Data Deep Dive

This section analyzes the raw capture data from individual controller tests, providing detailed latency distribution insights.

```{r raw-data-available, echo=FALSE}
n_devices_raw <- length(unique(raw_data$Device))
n_readings <- nrow(raw_data)
```

**Raw data available:** `r n_devices_raw` devices with `r format(n_readings, big.mark = ",")` total readings.

## Percentile Statistics from Raw Captures

```{r raw-percentile-table, echo=FALSE}
if (nrow(raw_stats) > 0) {
  raw_stats_display <- raw_stats %>%
    arrange(RawMean) %>%
    select(Device, N, RawMean, Median, P90, P95, P99, Consistency) %>%
    rename(
      `Readings` = N,
      `Mean (ms)` = RawMean,
      `Median (ms)` = Median,
      `P90 (ms)` = P90,
      `P95 (ms)` = P95,
      `P99 (ms)` = P99,
      `Consistency %` = Consistency
    ) %>%
    mutate(across(where(is.numeric), ~round(., 2)))

  datatable(raw_stats_display,
            options = list(pageLength = 15, scrollX = TRUE),
            caption = "Percentile statistics from raw capture data (lower is better, higher consistency is better)")
}
```

## Latency Distribution by Device

Showing the 16 devices with the most raw data readings for statistical reliability.

```{r raw-histogram-plotly, echo=FALSE, fig.height=10, fig.width=14, warning=FALSE}
if (nrow(raw_data) > 0) {
  # Get top 16 devices by reading count for statistical reliability
  top_devices <- raw_data %>%
    count(Device) %>%
    arrange(desc(n)) %>%
    head(16) %>%
    pull(Device)

  raw_subset <- raw_data %>%
    filter(Device %in% top_devices) %>%
    mutate(DeviceShort = truncate_name(Device, 30))

  p_hist <- raw_subset %>%
    ggplot(aes(x = delay, fill = DeviceShort)) +
    geom_histogram(bins = 40, alpha = 0.7, position = "identity") +
    facet_wrap(~DeviceShort, scales = "free_y", ncol = 4) +
    geom_vline(xintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
    labs(title = "Latency Distribution (Raw Data)",
         subtitle = "Top 16 devices by number of readings",
         x = "Latency (ms)", y = "Count") +
    theme_minimal() +
    theme(legend.position = "none",
          strip.text = element_text(size = 7),
          axis.text = element_text(size = 6))

  ggplotly(p_hist, height = 700, width = 1400) %>%
    layout(hovermode = "closest")
}
```

## Time-Series Pattern Viewer

Shows first 200 readings from the 8 devices with the most raw data (minimum 200 readings required). Look for periodic sawtooth patterns indicating polling intervals.

```{r raw-timeseries-plotly, echo=FALSE, fig.height=12, fig.width=14, warning=FALSE}
if (nrow(raw_data) > 0) {
  # Select devices with most readings (min 200) for pattern analysis
  devices_with_enough_data <- raw_data %>%
    count(Device) %>%
    filter(n >= 200) %>%
    arrange(desc(n)) %>%
    head(8) %>%
    pull(Device)

  pattern_subset <- raw_data %>%
    filter(Device %in% devices_with_enough_data) %>%
    group_by(Device) %>%
    slice_head(n = 200) %>%
    ungroup() %>%
    mutate(DeviceShort = truncate_name(Device, 35))

  if (nrow(pattern_subset) > 0) {
    p_pattern <- pattern_subset %>%
      ggplot(aes(x = read, y = delay, color = DeviceShort)) +
      geom_line(alpha = 0.7) +
      geom_point(size = 0.5, alpha = 0.5) +
      facet_wrap(~DeviceShort, scales = "free_y", ncol = 2) +
      geom_hline(yintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
      labs(title = "Latency Time Series (First 200 Readings)",
           subtitle = "Top 8 devices by number of readings",
           x = "Reading Number", y = "Latency (ms)") +
      theme_minimal() +
      theme(legend.position = "none",
            strip.text = element_text(size = 8))

    ggplotly(p_pattern, height = 700, width = 1400) %>%
      layout(hovermode = "closest")
  }
}
```

## Consistency Analysis

Devices with higher consistency scores have more predictable latency (less variance relative to mean).

```{r consistency-plotly, echo=FALSE, fig.width=12, warning=FALSE}
if (nrow(raw_stats) > 0) {
  p_consistency <- raw_stats %>%
    filter(!is.na(Consistency)) %>%
    mutate(DeviceShort = truncate_name(Device, 40)) %>%
    ggplot(aes(x = RawMean, y = Consistency, text = DeviceShort)) +
    geom_point(aes(size = N), alpha = 0.7, color = '#2708A0') +
    geom_hline(yintercept = 90, color = '#22A722', linetype = "dashed") +
    geom_vline(xintercept = 100 / 6, color = '#BA1B1D', linetype = "dashed") +
    labs(title = "Latency vs Consistency",
         subtitle = "Green line: 90% consistency threshold. Red line: one frame.",
         x = "Mean Latency (ms)", y = "Consistency Score (%)",
         size = "# Readings") +
    theme_minimal() +
    theme(axis.text = element_text(size = 10),
          axis.title = element_text(size = 11))

  ggplotly(p_consistency, tooltip = c("text", "x", "y"), width = 1200, height = 500) %>%
    layout(hovermode = "closest")
}
```

# Latency Ranges

These plots show approximate latency ranges using 95% confidence intervals. Due to limited data, some standard deviations were imputed using linear regression. Imputed values are shown in a different color.

Use the filters below to show specific device types and connection methods.

```{r latency-range-filters, echo=FALSE}
# Prepare data for filtered plot
range_plot_dat <- dat %>%
  filter(!is.na(`Wired/Wireless`), !is.na(Category)) %>%
  mutate(
    DeviceLabel = gsub("<[^>]+>", "", Device),
    DeviceShort = truncate_name(DeviceLabel, 45)
  )

shared_range_dat <- SharedData$new(range_plot_dat)

bscols(widths = c(12),
  list(
    filter_checkbox("ConnectionType", "Connection", shared_range_dat, ~`Wired/Wireless`, inline = TRUE),
    filter_checkbox("DeviceCategory", "Category", shared_range_dat, ~Category, inline = TRUE)
  )
)
```

```{r latency-range-plot, echo=FALSE, fig.height=20, fig.width=14, warning=FALSE}
# Create the plot with shared data
p_range <- plot_ly(shared_range_dat,
                   y = ~reorder(DeviceShort, `Latency (in ms)`),
                   x = ~`Latency (in ms)`,
                   type = 'scatter',
                   mode = 'markers',
                   marker = list(size = 8, color = '#333'),
                   error_x = list(
                     type = 'data',
                     symmetric = FALSE,
                     arrayminus = ~(`Latency (in ms)` - `SD down`),
                     array = ~(`SD up` - `Latency (in ms)`),
                     color = ~ifelse(Imputed, '#E63946', '#457B9D'),
                     thickness = 2
                   ),
                   text = ~paste0(DeviceLabel,
                                  "<br>Latency: ", round(`Latency (in ms)`, 2), " ms",
                                  "<br>Category: ", Category,
                                  "<br>Connection: ", `Wired/Wireless`),
                   hoverinfo = 'text') %>%
  layout(
    title = "Device Latency Ranges (95% CI)",
    xaxis = list(title = "Latency (ms)", zeroline = TRUE),
    yaxis = list(title = "", tickfont = list(size = 9)),
    shapes = list(
      list(type = "line", x0 = 100/6, x1 = 100/6, y0 = 0, y1 = 1,
           yref = "paper", line = list(color = "#BA1B1D", dash = "dash", width = 2))
    ),
    annotations = list(
      list(x = 100/6, y = 1.02, yref = "paper", text = "One Frame (16.67ms)",
           showarrow = FALSE, font = list(size = 10, color = "#BA1B1D"))
    ),
    margin = list(l = 300, r = 50, t = 80, b = 50),
    height = max(500, nrow(range_plot_dat) * 18)
  )

p_range
```

<small>**Note:** Red error bars indicate imputed standard deviation (estimated via linear regression). Blue bars are measured values.</small>

# Best Performers by Category

Top 3 performing devices in each category, separated by wired and wireless connection.

```{r best-performers, echo=FALSE}
# Get top 3 wired devices per category
best_wired <- dat %>%
  filter(`Wired/Wireless` == "Wired", !is.na(Category)) %>%
  group_by(Category) %>%
  slice_min(`Latency (in ms)`, n = 3, with_ties = FALSE) %>%
  mutate(Rank = row_number()) %>%
  ungroup() %>%
  mutate(Connection = "Wired") %>%
  select(Category, Connection, Rank, Device = DeviceClean, `Latency (in ms)`)

# Get top 3 wireless devices per category
best_wireless <- dat %>%
  filter(`Wired/Wireless` == "Wireless", !is.na(Category)) %>%
  group_by(Category) %>%
  slice_min(`Latency (in ms)`, n = 3, with_ties = FALSE) %>%
  mutate(Rank = row_number()) %>%
  ungroup() %>%
  mutate(Connection = "Wireless") %>%
  select(Category, Connection, Rank, Device = DeviceClean, `Latency (in ms)`)

# Combine and arrange
best_performers <- bind_rows(best_wired, best_wireless) %>%
  arrange(Category, Connection, Rank) %>%
  mutate(
    `Latency (in ms)` = round(`Latency (in ms)`, 2),
    Rank = paste0("#", Rank)
  )

datatable(best_performers,
          options = list(
            pageLength = 50,
            dom = 'ft',
            columnDefs = list(
              list(className = 'dt-left', targets = c(0, 1, 3)),
              list(className = 'dt-center', targets = 2),
              list(className = 'dt-right', targets = 4)
            )
          ),
          filter = 'top',
          rownames = FALSE,
          caption = "Top 3 devices per category and connection type (lowest latency)")
```

# Methodology

This data was collected using a closed-loop latency testing system consisting of:

- **Arduino Pro Micro** - Triggers virtual button presses and measures response time via hardware interrupt
- **DE10-nano with MiSTer FPGA** - Running the NES Lag Tester core to detect inputs
- **Custom test PCB** - Connects the Arduino, controller pins, and DE10-nano

The Arduino triggers a button press on the controller under test, and measures the time until the MiSTer core detects the input. Results are captured via serial output in CSV format.

For more details, see the [GitHub repository](https://github.com/misteraddons/inputlatency).
